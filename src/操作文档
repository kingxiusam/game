1.erlang切换到指定目录的内置函数:cd(),eg:cd("C:/Users/Administrator/IdeaProjects/game/src")。
2.
  给Windows用户的一个小技巧.创建一个名为C:/program Files/er15.4.12/.Erlang的
  文件（根据实际的安装路径进行调整）、然后在文件中加入如下的内容:
  io:format("consulting . Erlang in "p-n",
  [element(2. Fitle:get cwd()]).
   %%Edit to the directory where you store your code
  io:format("now in:"p-n", [element(2 ft11e:get. Cwdo))]).
  保存之后，每次启动Erlang时，它如能自动切换到目录C:/WORAK.
3.能够返回fun和接收fun的函数都称为高阶函数。
4.lists.map(F,L)。将函数F应用到列表L。
    13> L=[1,2,3,4].
    [1,2,3,4]
    14> lists:map(Double,L).
    [2,4,6,8]

5.list.filter(P,L).过滤返回包含L列表中满足函数P的元素的新列表。
    13> L=[1,2,3,4].
    [1,2,3,4]
    16> P=fun(X)->X>3 end.
    #Fun<erl_eval.6.90072148>
    17> lists:filter(P,L).
    [4]

6.
    div 取除数
    rem 取余数
7.将列表L转换为测试函数，测试传入的参数是否为L中的元素
    MakeTest= fun(L)  ->(fun(X)  -> lists:member(X,L) end) end.
    eg: 24> Fruit=[apples,milk,pears].
        [apples,milk,pears]
        25> IsFruit=MakeTest(Fruit).
        #Fun<erl_eval.6.90072148>
        26> IsFruit(apples).
        true
        27> IsFruit(apple).
        false
        28> IsFruit(milk).
        true
        29> IsFruit(pears).
        true
        30>

8.
    Muti=fun(Times)->(fun(X)->X*Times end) end.
    eg:
       Muti=fun(Times)->(fun(X)->X*Times end) end.
       #Fun<erl_eval.6.90072148>
       31> Muti(3).
       #Fun<erl_eval.6.90072148>
       32> Triple=Muti(3).
       #Fun<erl_eval.6.90072148>
       33> Triple(5).


9.
    if,switch,for,while  -------  模式匹配,高阶函数

10.
    %%自定义for循环实现
    for(Max,Max,F)->[F(Max)];
    for(I,Max,F)->[F(I)|for(I+1,Max,F)].

    eg:
        34> c(pp).
        {ok,pp}
        35> pp:for(1,10,fun(I)->I end).
        [1,2,3,4,5,6,7,8,9,10]
        36>pp:for(1,10,fun(X)->X*X end).
           [1,4,9,16,25,36,49,64,81,100]

11.    [{构造器}||{元组/用于匹配L中每个元素的模式}<-L]
    eg:
        45> [{Name,2*Number}||{Name,Number}<-Buy].
        [{apples,2},{pears,4},{milk,6}]

12.
       列表解释的常见表达式 [X||qualifier1,qualifier2,qualifier3] qualifier可以是生成器和过滤器
       51>[X||{a,X}<-[{a,4},{b,1},{c,5},{a,2},hello,"wow"]].
       [4,2]
13.
        %%快速排序算法:以Pivot为基准进行排序
        qsort([])->[];
        qsort([Pivot|T])->qsort([X||X<-T,X=<Pivot])
                ++[Pivot]++
                qsort([X||X<-T,X>Pivot]).
14.
        %%生成毕达格拉斯三元组
        pythag(N)->[{A,B,C}||
        %%            使用生成器和过滤器
                        A<-lists:seq(1,N),
                        B<-lists:seq(1,N),
                        C<-lists:seq(1,N),
                        A+B+C=<N,
                        A*A+B*B=:=C*C
                    ].
            eg:61> pp:pythag(9).
               []
               62> pp:pythag(30).
               [{3,4,5},{4,3,5},{5,12,13},{6,8,10},{8,6,10},{12,5,13}]
               63>

15.
        X--Y的--是列表的分离操作符（详见第5章）

16.
        用于强化模式匹配的结构

17.
        erlang中的短路布尔表达式：andalso,oralso

18.
        true(原子)断言在if表达式中的应用

19.
        record(记录)
        记录的定义和操纵：

        eg: 76> X=#todo{}.
            #todo{status = reminder,who = joe,text = undefined}

            75> rr("records.hrl").
            [todo]
            76> X=#todo.
            * 1: syntax error before: '.'
            76> X=#todo{}.
            #todo{status = reminder,who = joe,text = undefined}
            77> X1=#todo{status=urgent,text="fix errodata in file"}.
            #todo{status = urgent,who = joe,
                  text = "fix errodata in file"}
            78> X2=X1#todo{status=done}.
            #todo{status = done,who = joe,text = "fix errodata in file"}

20.
            记录是元组的伪装 使用rf()释放记录的定义
            eg：9> X.
               #todo{status = reminder,who = joe,text = undefined}
               10> rf(todo).
               ok
               11> X.
               {todo,reminder,joe,undefined}

21.
            遇到系统内部错误需要抛出异常时，可以在代码中显式抛出异常: throw(Exception),exit(Exception),erlang.error(Exception)(3个异常标签)。
22.         finally  在try()表达式执行完之后执行
                eg:
                    46> c(try_code).
                    {ok,try_code}
                    47> try_code:try_caught().
                    success
                    success
                    success
                    success
                    success
                    [{1,noraml,a},
                     {2,caught,thow,a},
                     {3,caught,exit,a},
                     {4,noraml,{"error",a}},
                     {5,caught,error,a}]


23.
              %%包装math:sqrt函数,程序异常时按照指定格式抛出相关异常信息
              eg:
                  sqrt(Number) when Number<0 ->
                      erlang:error({squareNegativeRootAgument,Number});
                  sqrt(Number)-> math:sqrt(Number).

24.
                2进制数据为可打印的字符串，shell显示为字符串的形式，否则为一组整数。
                    eg:
                        56> <<99,97,116>>.
                        <<"cat">>
                        58> <<1,2,3>>.
                        <<1,2,3>>

25.
                -spec 用于描述函数的参数和返回值类型
                    eg:
                        %% list_to_binary/1
                        -spec list_to_binary(IoList) -> binary() when
                              IoList :: iolist().
                        list_to_binary(_IoList) ->
                            erlang:nif_error(undefined).

                63> term_to_binary(["boy",person,23]).
                <<131, 108,0,0,0, 3,107,0,3,98,111,121,100,0,6,112,101,114,115,111,110,97,23,  106>>
                64> term_to_binary({"boy",person,23}).
                <<131,104,        3,107,0,3,98,111,121,100,0,6,112,101,114,115, 111,110,97,23      >>

26.比特语法

                77> Red=2.
                2
                78> Green=61.
                61
                79> Blue=20.
                20
                80> Mem = <<Red:5,Green:6,Blue:5>>.
                <<23,180>>
                82> <<C1:5,C2:6,C3:5>>=Mem.
                <<23,180>>
                83> C1.
                2
                84> C2.
                61
                85> C3.


27.                87> apply(lib_misc,max,[2,3])   <=> lib_misc:max(2,3).

28.             导出该模块的所有函数
                    -compile(export_all)

29.
                begin end块的值就是块中最后一个表达式的值

30.             ~w是指对列表进行原封不动的输出,124> io:format("~w",["hello""hi"]).
                [104,101,108,108,111,104,105]

                133> io:format("~w",[104,101,108,108,111,104,105]).
                ** exception error: bad argument
                     in function  io:format/3

                134> io:format("~w",["hello","hi"]).
                ** exception error: bad argument
                     in function  io:format/3




31.             %% get/0 获取[{Key, Val}]列表形式的字典
                -spec get() -> [{Key, Val}] when
                      Key :: term(),
                      Val :: term().
                get() ->
                    erlang:nif_error(undefined).

                %% get/1 获取指定Key的Value值
                -spec get(Key) -> Val | undefined when
                      Key :: term(),
                      Val :: term().
                get(_Key) ->
                    erlang:nif_error(undefined).

                %% get_keys/1 获取值为Val的Key列表
                -spec get_keys(Val) -> [Key] when
                      Val :: term(),
                      Key :: term().
                get_keys(_Val) ->
                    erlang:nif_error(undefined).

                %% erase/0 返回[{Key, Val}],并删除整个进程字典
                -spec erase() -> [{Key, Val}] when
                      Key :: term(),
                      Val :: term().
                erase() ->
                    erlang:nif_error(undefined).

                %% erase/1 返回Key对应得值Val/undefined,并删除Key对应得Val值
                -spec erase(Key) -> Val | undefined when
                      Key :: term(),
                      Val :: term().
                erase(_Key) ->
                    erlang:nif_error(undefined).

32.
                引用: erlang:make_ref()创建引用,适用于创建唯一标签的场合。

33.             布尔表达式           or      and
                短路布尔表达式     oralso  andalso

34.             下划线变量,在定义的常规变量将未被使用时，使用下划线变量可避免潜在的bug和警告

35.             新增目录Dir到加载路径的头部 shell命令: -pa Dir
                -spec add_patha(Dir) -> add_path_ret() when
                      Dir :: file:filename().
                add_patha(Dir) when is_list(Dir) -> call({add_path,first,Dir}).

                新增目录Dir到加载路径的尾部 shell命令：-pz Dir
                -spec add_pathz(Dir) -> add_path_ret() when
                      Dir :: file:filename().
                add_pathz(Dir) when is_list(Dir) -> call({add_path,last,Dir}).
36.
                使用Makefile自动编译：



                经过这些步露，最后我们得到一个非常精简的make file,大概就像下面一样:
                .SUFFIXES: , erl . Beam
                .erl. Beam:
                erlc -W $<
                ERL . Erl -boot start clean
                MOOS = module l module2 module3
                all:compile
                .
                .
                .
37.
                3个新原语：spawn,send(使用!操作符),receiver
1.erlang切换到指定目录的内置函数:cd(),eg:cd("C:/Users/Administrator/IdeaProjects/game/src")。
2.
  给Windows用户的一个小技巧.创建一个名为C:/program Files/er15.4.12/.Erlang的
  文件（根据实际的安装路径进行调整）、然后在文件中加入如下的内容:
  io:format("consulting . Erlang in "p-n",
  [element(2. Fitle:get cwd()]).
   %%Edit to the directory where you store your code
  io:format("now in:"p-n", [element(2 ft11e:get. Cwdo))]).
  保存之后，每次启动Erlang时，它如能自动切换到目录C:/WORAK.
3.能够返回fun和接收fun的函数都称为高阶函数。
4.lists.map(F,L)。将函数F应用到列表L。
    13> L=[1,2,3,4].
    [1,2,3,4]
    14> lists:map(Double,L).
    [2,4,6,8]

5.list.filter(P,L).过滤返回包含L列表中满足函数P的元素的新列表。
    13> L=[1,2,3,4].
    [1,2,3,4]
    16> P=fun(X)->X>3 end.
    #Fun<erl_eval.6.90072148>
    17> lists:filter(P,L).
    [4]

6.
    div 取除数
    rem 取余数
7.将列表L转换为测试函数，测试传入的参数是否为L中的元素
    MakeTest= fun(L)  ->(fun(X)  -> lists:member(X,L) end) end.
    eg: 24> Fruit=[apples,milk,pears].
        [apples,milk,pears]
        25> IsFruit=MakeTest(Fruit).
        #Fun<erl_eval.6.90072148>
        26> IsFruit(apples).
        true
        27> IsFruit(apple).
        false
        28> IsFruit(milk).
        true
        29> IsFruit(pears).
        true
        30>

8.
    Muti=fun(Times)->(fun(X)->X*Times end) end.
    eg:
       Muti=fun(Times)->(fun(X)->X*Times end) end.
       #Fun<erl_eval.6.90072148>
       31> Muti(3).
       #Fun<erl_eval.6.90072148>
       32> Triple=Muti(3).
       #Fun<erl_eval.6.90072148>
       33> Triple(5).


9.
    if,switch,for,while  -------  模式匹配,高阶函数

10.
    %%自定义for循环实现
    for(Max,Max,F)->[F(Max)];
    for(I,Max,F)->[F(I)|for(I+1,Max,F)].

    eg:
        34> c(pp).
        {ok,pp}
        35> pp:for(1,10,fun(I)->I end).
        [1,2,3,4,5,6,7,8,9,10]
        36>pp:for(1,10,fun(X)->X*X end).
           [1,4,9,16,25,36,49,64,81,100]

11.    [{构造器}||{元组/用于匹配L中每个元素的模式}<-L]
    eg:
        45> [{Name,2*Number}||{Name,Number}<-Buy].
        [{apples,2},{pears,4},{milk,6}]

12.
       列表解释的常见表达式 [X||qualifier1,qualifier2,qualifier3] qualifier可以是生成器和过滤器
       51>[X||{a,X}<-[{a,4},{b,1},{c,5},{a,2},hello,"wow"]].
       [4,2]
13.
        %%快速排序算法:以Pivot为基准进行排序
        qsort([])->[];
        qsort([Pivot|T])->qsort([X||X<-T,X=<Pivot])
                ++[Pivot]++
                qsort([X||X<-T,X>Pivot]).
14.
        %%生成毕达格拉斯三元组
        pythag(N)->[{A,B,C}||
        %%            使用生成器和过滤器
                        A<-lists:seq(1,N),
                        B<-lists:seq(1,N),
                        C<-lists:seq(1,N),
                        A+B+C=<N,
                        A*A+B*B=:=C*C
                    ].
            eg:61> pp:pythag(9).
               []
               62> pp:pythag(30).
               [{3,4,5},{4,3,5},{5,12,13},{6,8,10},{8,6,10},{12,5,13}]
               63>

15.
        X--Y的--是列表的分离操作符（详见第5章）

16.
        用于强化模式匹配的结构

17.
        erlang中的短路布尔表达式：andalso,oralso

18.
        true(原子)断言在if表达式中的应用

19.
        record(记录)
        记录的定义和操纵：

        eg: 76> X=#todo{}.
            #todo{status = reminder,who = joe,text = undefined}

            75> rr("records.hrl").
            [todo]
            76> X=#todo.
            * 1: syntax error before: '.'
            76> X=#todo{}.
            #todo{status = reminder,who = joe,text = undefined}
            77> X1=#todo{status=urgent,text="fix errodata in file"}.
            #todo{status = urgent,who = joe,
                  text = "fix errodata in file"}
            78> X2=X1#todo{status=done}.
            #todo{status = done,who = joe,text = "fix errodata in file"}

20.
            记录是元组的伪装 使用rf()释放记录的定义
            eg：9> X.
               #todo{status = reminder,who = joe,text = undefined}
               10> rf(todo).
               ok
               11> X.
               {todo,reminder,joe,undefined}

21.
            遇到系统内部错误需要抛出异常时，可以在代码中显式抛出异常: throw(Exception),exit(Exception),erlang.error(Exception)(3个异常标签)。
22.         finally  在try()表达式执行完之后执行
                eg:
                    46> c(try_code).
                    {ok,try_code}
                    47> try_code:try_caught().
                    success
                    success
                    success
                    success
                    success
                    [{1,noraml,a},
                     {2,caught,thow,a},
                     {3,caught,exit,a},
                     {4,noraml,{"error",a}},
                     {5,caught,error,a}]


23.
              %%包装math:sqrt函数,程序异常时按照指定格式抛出相关异常信息
              eg:
                  sqrt(Number) when Number<0 ->
                      erlang:error({squareNegativeRootAgument,Number});
                  sqrt(Number)-> math:sqrt(Number).

24.
                2进制数据为可打印的字符串，shell显示为字符串的形式，否则为一组整数。
                    eg:
                        56> <<99,97,116>>.
                        <<"cat">>
                        58> <<1,2,3>>.
                        <<1,2,3>>

25.
                -spec 用于描述函数的参数和返回值类型
                    eg:
                        %% list_to_binary/1
                        -spec list_to_binary(IoList) -> binary() when
                              IoList :: iolist().
                        list_to_binary(_IoList) ->
                            erlang:nif_error(undefined).

                63> term_to_binary(["boy",person,23]).
                <<131, 108,0,0,0, 3,107,0,3,98,111,121,100,0,6,112,101,114,115,111,110,97,23,  106>>
                64> term_to_binary({"boy",person,23}).
                <<131,104,        3,107,0,3,98,111,121,100,0,6,112,101,114,115, 111,110,97,23      >>

26.比特语法

                77> Red=2.
                2
                78> Green=61.
                61
                79> Blue=20.
                20
                80> Mem = <<Red:5,Green:6,Blue:5>>.
                <<23,180>>
                82> <<C1:5,C2:6,C3:5>>=Mem.
                <<23,180>>
                83> C1.
                2
                84> C2.
                61
                85> C3.


27.                87> apply(lib_misc,max,[2,3])   <=> lib_misc:max(2,3).

28.             导出该模块的所有函数
                    -compile(export_all)

29.
                begin end块的值就是块中最后一个表达式的值

30.             ~w是指对列表进行原封不动的输出,124> io:format("~w",["hello""hi"]).
                [104,101,108,108,111,104,105]

                133> io:format("~w",[104,101,108,108,111,104,105]).
                ** exception error: bad argument
                     in function  io:format/3

                134> io:format("~w",["hello","hi"]).
                ** exception error: bad argument
                     in function  io:format/3




31.             %% get/0 获取[{Key, Val}]列表形式的字典
                -spec get() -> [{Key, Val}] when
                      Key :: term(),
                      Val :: term().
                get() ->
                    erlang:nif_error(undefined).

                %% get/1 获取指定Key的Value值
                -spec get(Key) -> Val | undefined when
                      Key :: term(),
                      Val :: term().
                get(_Key) ->
                    erlang:nif_error(undefined).

                %% get_keys/1 获取值为Val的Key列表
                -spec get_keys(Val) -> [Key] when
                      Val :: term(),
                      Key :: term().
                get_keys(_Val) ->
                    erlang:nif_error(undefined).

                %% erase/0 返回[{Key, Val}],并删除整个进程字典
                -spec erase() -> [{Key, Val}] when
                      Key :: term(),
                      Val :: term().
                erase() ->
                    erlang:nif_error(undefined).

                %% erase/1 返回Key对应得值Val/undefined,并删除Key对应得Val值
                -spec erase(Key) -> Val | undefined when
                      Key :: term(),
                      Val :: term().
                erase(_Key) ->
                    erlang:nif_error(undefined).

32.
                引用: erlang:make_ref()创建引用,适用于创建唯一标签的场合。

33.             布尔表达式           or      and
                短路布尔表达式     oralso  andalso

34.             下划线变量,在定义的常规变量将未被使用时，使用下划线变量可避免潜在的bug和警告

35.             新增目录Dir到加载路径的头部 shell命令: -pa Dir
                -spec add_patha(Dir) -> add_path_ret() when
                      Dir :: file:filename().
                add_patha(Dir) when is_list(Dir) -> call({add_path,first,Dir}).

                新增目录Dir到加载路径的尾部 shell命令：-pz Dir
                -spec add_pathz(Dir) -> add_path_ret() when
                      Dir :: file:filename().
                add_pathz(Dir) when is_list(Dir) -> call({add_path,last,Dir}).
36.
                使用Makefile自动编译：



                经过这些步露，最后我们得到一个非常精简的make file,大概就像下面一样:
                .SUFFIXES: , erl . Beam
                .erl. Beam:
                erlc -W $<
                ERL . Erl -boot start clean
                MOOS = module l module2 module3
                all:compile
                .
                .
                .
37.
                3个新原语：spawn,send(使用!操作符),receiver
                spawn(Fun)创建新的并发进程对函数Fun进行求值,并返回进程id(Pid)--处理进程,
                eg:
                    3> Pid=spawn(fun area_server:loop/0).
                    <0.39.0>

                Pid ! Msg的值被定义为Msg,客户机向处理进程发送请求,Msg包含客户机请求信息(self(),A,B),可以是客户机自己的进程ID,其他请求参数


38.
                erlang每个进程都有自己的一个邮箱，向进程发送的消息都会被送入邮箱中
                        email    pattern1,pattern2    action

                        message1        not match        remove /save in savequeue
                        message2        not match        remove /save in savequeue
                        message3        not match        remove /save in savequeue

                        message4        match              未匹配消息message从保存队列savequue释放,重新放回进程邮箱


39.使用BIF管理进程

                %% register/2 将进程PidOrPort注册名为RegName的原子
                -spec register(RegName, PidOrPort) -> true when
                      RegName :: atom(),
                      PidOrPort :: port() | pid().
                register(_RegName, _PidOrPort) ->
                    erlang:nif_error(undefined).

                %% registered/0 返回系统中已注册的名称列表
                -spec registered() -> [RegName] when
                      RegName :: atom().
                registered() ->
                    erlang:nif_error(undefined).

                %% unregister/1 移除RegName对应进程的所有注册信息
                -spec unregister(RegName) -> true when
                      RegName :: atom().
                unregister(_RegName) ->
                    erlang:nif_error(undefined).

                %% whereis/1 判断RegName是否被其他进程注册,有则返回Pid，否则返回undefined。
                -spec whereis(RegName) -> pid() | port() | undefined when
                      RegName :: atom().
                whereis(_RegName) ->
                    erlang:nif_error(undefined).


40.尾递归技术
            编译尾递归函数时函数最后一个调用语句会被替换为简单的跳转指令,跳转到函数的开头部分。
            使用MFA模式动态更新运行进程：spawn(Module,Func,Args)


            显式的向进程Pid发送一个退出信号：exit(Pid,X).
            kill信号主要用于僵尸进程(谨慎使用)

41.捕获进程退出的编程模式




            1.模式1:我不在乎创建的进程是否崩溃
            下面这个进程仅使用spawn来创建一个并行进程:
            Pid . spawn(fun() ->. . End)
            如果没有其他语句。那么如果这个被生成的进程崩溃，当前进程会毫无察觉地继续执行自己
            的其他任务。
            2.模式2:如果我创建的进程崩溃那么我也自行消亡
            严格地讲，这里应改为"如果我创建的进程非正常的崩溃"。要达到这个目的，必须使用
            Spawn link来创建并行进程，而且一定不能在这之前将进程设为退出信号捕获状态。我们应该
            这么写:
            Pid - spawn_link(fun() - . . . End)
            此时，如果新生成的进程异常崩溃而发送非正常的退出信号，当前进程也会随之消亡。
            3.模式3:如果我创建的进程崩溃我需要处理错误
            在这种情况下，就要使用:spawn_link和trap_exit,代码如下:
            process_flag(trap_exit,true),
            Pid=spawn_link(fun() -> . . . End),
            loop (. . . ).
            1oop(state) ->
                        receive
                        {'EXIT', pid, reason] ->
                        %%do something with the error
                        1oop(state1);
                        ...
                        end
